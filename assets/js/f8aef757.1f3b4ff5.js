"use strict";(globalThis.webpackChunkmatrix_book=globalThis.webpackChunkmatrix_book||[]).push([[758],{7325:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"chapter-4-rag-basics","title":"chapter-4-rag-basics","description":"---","source":"@site/docs/chapter-4-rag-basics.md","sourceDirName":".","slug":"/chapter-4-rag-basics","permalink":"/ai-book-engineering/docs/chapter-4-rag-basics","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"chapter-3-docusaurus-setup","permalink":"/ai-book-engineering/docs/chapter-3-docusaurus-setup"},"next":{"title":"Chapter 5 \u2013 Qdrant Cloud + Embeddings + FastAPI","permalink":"/ai-book-engineering/docs/chapter-5-qdrant-setup"}}');var s=t(4848),a=t(8453);const o={},i=void 0,c={},d=[{value:"4\ufe0f\u20e3 <code>chapter-4-rag-basics.md</code>",id:"4\ufe0f\u20e3-chapter-4-rag-basicsmd",level:2}];function h(e){const n={code:"code",h2:"h2",hr:"hr",pre:"pre",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h2,{id:"4\ufe0f\u20e3-chapter-4-rag-basicsmd",children:["4\ufe0f\u20e3 ",(0,s.jsx)(n.code,{children:"chapter-4-rag-basics.md"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-markdown",children:"---\r\nid: chapter-4-rag-basics\r\ntitle: Chapter 4 \u2013 Understanding RAG (Retrieval Augmented Generation)\r\n---\r\n\r\nA simple language model answers questions using its **internal training data**.  \r\nBut in our project, we want the model to answer based on **this book\u2019s content** specifically.\r\n\r\nFor that, we use **RAG \u2013 Retrieval Augmented Generation**.\r\n\r\n## What Is RAG?\r\n\r\nRAG is a technique where the model:\r\n\r\n1. **Retrieves** relevant information from external documents  \r\n2. **Augments** its context with that information  \r\n3. **Generates** an answer using both the question and retrieved content\r\n\r\nIn our case, the external documents are the **Markdown files of this book**.\r\n\r\n## Core Components of RAG\r\n\r\nTo implement RAG, we need:\r\n\r\n- A way to store document snippets (chunks)  \r\n- A way to convert text into embeddings (vector representation)  \r\n- A **Vector Database** to store and search those embeddings  \r\n- A backend that:\r\n  - Receives user questions  \r\n  - Finds relevant text chunks  \r\n  - Sends both question and chunks to the LLM  \r\n  - Returns the final answer\r\n\r\n## RAG Flow for This Project\r\n\r\n1. **Preprocessing Step**\r\n   - Read all `.md` files from the `docs/` folder  \r\n   - Split each file into smaller chunks (for example, 300\u2013800 characters)  \r\n   - Create embeddings for each chunk  \r\n   - Store these embeddings in **Qdrant Cloud**\r\n\r\n2. **Query Step (User Asks a Question)**\r\n   - Convert the question into embeddings  \r\n   - Use Qdrant to find similar chunks  \r\n   - Send the question + top chunks to the LLM via ChatKit  \r\n   - Generate an answer based only on those chunks\r\n\r\n3. **Selected Text Mode (Bonus)**\r\n   - User selects some text in the book  \r\n   - Only that selected text is passed to the backend  \r\n   - Chatbot answers based **only** from that selected section\r\n\r\n## Why RAG Is Important in This Hackathon\r\n\r\n- It proves that the chatbot actually **uses the book content**  \r\n- It demonstrates your understanding of **embeddings and retrieval**  \r\n- It is a practical pattern used in real-world AI systems  \r\n\r\nRAG turns a static book into an **interactive knowledge system**.\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(6540);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);